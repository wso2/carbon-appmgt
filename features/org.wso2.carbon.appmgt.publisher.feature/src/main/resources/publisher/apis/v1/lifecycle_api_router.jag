<%
/*
 Description: Provides a means to attach life cycles to artifacts
 Note: type: shortName in the Rxt templates

 GET api/lifecycle/{asset-type}/{artifact-id}                : Returns the current lifecycle state of an artifact
 GET api/lifecycle/checklist/{type}/{id}                     : Returns the check list for an artifact
 GET api/lifecycle/checklistitem/{index}/{type}/{id}         : Returns the checked state of the check list item at
                                                               the given index.
 GET api/lifecycle/actions/{type}/{id}                       : Gets the actions available to an asset at a given state

 DELETE api/lifecycle/{asset-type}/{artifact-id}		     : Detaches the current lifecycle from the artifact
 DELETE api/lifecycle/checklistitem/{index}/{type}/{id}      : Unticks a check list item at the given index

 POST  api/lifecycle/{asset-type}/{artifact-id}   	         : Attach the provided lifecycle to the artifact
 POST api/lifecycle/checklistitem/{index}/{type}/{id}        : Ticks a check list item at the given index

 PUT api/lifecycle/{action}/{asset-type}/{artifact-id}	     : Performs the provided the action on the provided asset

 Filename:lifecycle_api_router.js
 Created Date: 6/8/2013
 */

require('/modules/publisher.js').exec(function (ctx) {

    var CONTENT_TYPE_JSON = "application/json";

    var LIFE_CYCLE_ACTION_SUBMIT_FOR_REVIEW = "Submit for Review";
    var LIFE_CYCLE_ACTION_APPROVE = "Approve";
    var LIFE_CYCLE_ACTION_REJECT = "Reject";
    var LIFE_CYCLE_ACTION_PUBLISH = "Publish";
    var LIFE_CYCLE_ACTION_UNPUBLISH = "Unpublish";
    var LIFE_CYCLE_ACTION_RE_PUBLISH = "Re-Publish";
    var LIFE_CYCLE_ACTION_DEPRECATE = "Deprecate";
    var LIFE_CYCLE_ACTION_RETIRE = "Retire";
    var LIFE_CYCLE_ACTION_RECYCLE = "Recycle";

    var APP_TYPE_WEB_APP = "webapp";
    var APP_TYPE_MOBILE_APP = "mobileapp";

	var config = require('/config/publisher.json');
	var caramel = require('caramel');
	var router = require('/modules/router-g.js').router();
	var routeManager = new router.Router();
	var log = new Log();
	var permissions = require('/modules/permissions.js').permissions;
    var apiProvider = jagg.module('manager').getAPIProviderObj();
    var apiIdentifier = Packages.org.wso2.carbon.appmgt.api.model.APIIdentifier;

	routeManager.register('POST', 'publisher', '/publisher/api/lifecycle/{type}/{id}', function (context) {
		var shortName = context.params.type;
		var id = context.params.id;
		var lifecycle = context.post.lifecycle;
		var invokeAction = '';
		//Check the config for a lifeCycleBehaviour block
		utility.isPresent(config, 'lifeCycleBehaviour', function (lifeCycleBehaviour) {
			utility.isPresent(lifeCycleBehaviour, lifeCycle, function (lifeCycleData) {
				utility.isPresent(lifeCycleData, 'onAttach', function (onAttach) {
					invokeAction = onAttach.action || '';
				});
			});

		});

		if (!lifecycle) {
			response.sendError(400, 'Missing required parameter: lifecycle');
			return;
		}

		var artifactManager = rxtManager.getArtifactManager(shortName);
		try {
			var artifact = artifactManager.get(id);
			artifactManager.attachLifecycle(lifecycle, artifact);
			//Perform the action if the user has specified an action
			if (invokeAction != '') {
				artifactManager.promoteLifecycleState(invokeAction, artifact);
			}

			var msg = {};
			msg['status'] = 'ok';
            response.contentType = "application/json";
			print(msg);
		} catch (e) {
			log.debug('The asset with id: ' + id + ' could not be found.The following exception was thrown: ' + e);
			response.sendError(404, 'The asset with id: ' + id + ' could not be found.Please refere to the server log.');
		}
	});

	/*
	 Ticks the check list item at the provided index
	 */
	routeManager.register('POST', 'publisher', '/publisher/api/lifecycle/checklistitem/{index}/{type}/{id}', function (context) {

		var checkListItemIndex = context.params.index;
		var shortName = context.params.type;
		var id = context.params.id;
		var artifactManager = rxtManager.getArtifactManager(shortName);

		try {
			var artifact = artifactManager.get(id);
			artifactManager.checkItem(checkListItemIndex, artifact);
			var msg = {};
			msg['status'] = 'ok';
		} catch (e) {
			log.debug('The asset with id: ' + id + ' could not be found.The following exception was thrown: ' + e);
			response.sendError(404, 'The asset with id: ' + id + ' could not be found.Please refer to the server log.');
		}
	});

	routeManager.register('DELETE', 'publisher', '/publisher/api/lifecycle/{type}/{id}', function (context) {

		var shortName = context.params.type;
		var id = context.params.id;
		var artifactManager = rxtManager.getArtifactManager(shortName);
		try {
			var artifact = artifactManager.get(id);
			artifactManager.detachLifecycle(artifact);

			var msg = {};
			msg['status'] = 'ok';
            response.contentType = "application/json";
			print(msg);
		} catch (e) {
			log.debug('The asset with id: ' + id + ' could not be found.The following exception was thrown: ' + e);
			response.sendError(404, 'The asset with id: ' + id + ' could not be found.Please refer to the server log.');
		}

	});

	/*
	 Unticks the check list item at the given index
	 */
	routeManager.register('DELETE', 'publisher', '/publisher/api/lifecycle/checklistitem/{index}/{type}/{id}', function (context) {
		var checkListItemIndex = context.params.index;
		var shortName = context.params.type;
		var id = context.params.id;
		var artifactManager = rxtManager.getArtifactManager(shortName);

		try {
			var artifact = artifactManager.get(id);
			artifactManager.uncheckItem(checkListItemIndex, artifact);
			var msg = {};
			msg['status'] = 'ok';
		} catch (e) {
			log.debug('The lifecyle check list item at index ' + checkListItemIndex + ' of asset id: ' + id + ' could not be unticked' + 'The following exception was thrown: ' + e);
			response.sendError(404, 'The lifecycle check list item at index ' + checkListItemIndex + ' of asset id: ' + id + ' could not be unchecked' + '.Please refer to the server log');
		}
	});


    /**
     * API for handling web/mobile apps lifecycle transitions. Content type of the PUT request
     * should be 'application/json'.
     * @returns {{status: string, messages: string[], artifacts: Object[]}}
     */
    routeManager.register('PUT', 'publisher', '/publisher/api/lifecycle/{action}/{type}/{id}', function (context) {
        var appType = context.params.type; // webapp or mobileapp
        var action = context.params.action; // see '/config/publisher.json' --> publisherActions
        var uuid = context.params.id; // UUID

        /** @type {{status: string, messages: string[], artifacts: Object[]}} */
        var content = {status: "", messages: [], artifacts: []};

        // validating action
        if (config.publisherActions.indexOf(action) == -1) {
            log.error("Invalid '" + action + "' action invoked on a " + appType + " with UUID '" + uuid + "'.");
            response.status = 422; // Unprocessable Entity (WebDAV; RFC 4918)
            response.contentType = CONTENT_TYPE_JSON;
            content.status = "Invalid Action";
            content.messages.push("'" + action + "' action cannot be performed on " + appType + "s.");
            response.content = stringify(content);
            return;
        }

        var userManager = server.userManager(server.current(session).tenantId);
        var user = server.current(session);
        var permission = null;

        //check if its the default version and if it has any other versions when deprecating
        if (action == LIFE_CYCLE_ACTION_DEPRECATE) {
            var app;
            try {
                app = apiProvider.getAppDetailsFromUUID(uuid);
            } catch (e) {
                log.error("The asset with UUID '" + uuid + "' could not be retrieved.");
                log.error(e);
                response.status = 404;
                response.contentType = CONTENT_TYPE_JSON;
                content.status = "Not Found";
                content.messages.push("The " + appType + " with UUID " + uuid + " cannot be retrieved.");
                response.content = stringify(content);
                return;
            }
            var appProvider = app.provider;
            var appName = app.name;
            var appVersion = app.version;
            var apiIdentifierObj = new apiIdentifier(appProvider, appName, appVersion);

            try {
                if (apiProvider.isDefaultVersion(apiIdentifierObj) && apiProvider.hasMoreVersions(apiIdentifierObj)) {
                    var msg = "'Deprecate' action is not permitted as this is the default version (" + appVersion
                              + ") of '" + appName + "' " + appType + ". Please select other version of this " + appType
                              + " as the default version and proceed.";
                    log.warn(msg);
                    response.status = 403;
                    response.contentType = CONTENT_TYPE_JSON;
                    content.status = "Access Denied";
                    content.messages.push(msg);
                    response.content = stringify(content);
                    return;
                }
            } catch (e) {
                var msg = "Cannot retrieve default version details of '" + appVersion + "' version of '" + appName
                          + "' " + appType + " published by '" + appProvider + "'.";
                log.error(msg);
                log.error(e);
                response.status = 500;
                response.contentType = CONTENT_TYPE_JSON;
                content.status = "Error";
                content.messages.push(msg);
                response.content = stringify(content);
                return;
            }
        }

        // To Send an app to submit for review, created permission is required.
        if (action != LIFE_CYCLE_ACTION_SUBMIT_FOR_REVIEW) {
            if (appType == APP_TYPE_WEB_APP) {
                permission = config.permissions.webapp_publish;
            } else if (appType == APP_TYPE_MOBILE_APP) {
                permission = config.permissions.mobileapp_publish;
            }
        } else {
            if (appType == APP_TYPE_WEB_APP) {
                permission = config.permissions.webapp_create;
            } else if (appType == APP_TYPE_MOBILE_APP) {
                permission = config.permissions.mobileapp_create;
            }
        }

        // check whether current user has enough permission to change the life cycle
        var hasPermission = permissions.isAuthorized(user.username, permission, userManager);
        if (!hasPermission) {
            log.error("Insufficient permissions to perform '" + action + "' on " + appType + ".");
            response.status = 401;
            response.contentType = CONTENT_TYPE_JSON;
            content.status = "Access Denied";
            content.messages.push("You do not have publisher permissions to perform '" + action + "' action on "
                                  + appType + "s.");
            response.content = stringify(content);
            return;
        }

        var carbon = require('carbon');
        var artifactManager = rxtManager.getSystemArtifactManager(appType, session);

        try {
            var currentArtifact = artifactManager.get(uuid);
        } catch (e) {
            // this exception is thrown by
            // GenericArtifactManager.getGenericArtifact(id) throws GovernanceException
            log.error("The asset with UUID " + uuid + " could not be retrieved.");
            log.error(e);
            response.status = 404;
            response.contentType = CONTENT_TYPE_JSON;
            content.status = "Not Found";
            content.messages.push("The " + appType + " with UUID " + uuid + " cannot be retrieved.");
            response.content = stringify(content);
            return;
        }

        // grant permissions
        var roles = (context.content) ? context.content.roles : null;
        if (roles && (roles.length > 0)) {
            var currentRole = null;
            try {
                roles.forEach(function (role) {
                    currentRole = role;
                    userManager.authorizeRole(currentRole, currentArtifact.path,
                                              carbon.registry.actions.GET);
                });
            } catch (e) {
                log.error("Cannot grant permissions to '" + currentRole + "' role to perform action '"
                          + carbon.registry.actions.GET + "' action.");
                log.error(e);
                // continue work flow
            }
        }

        // check permissions to perform life cycle action
        try {
            if (!permissions.isLCActionsPermitted(user.username, currentArtifact.path,
                                                  userManager)) {
                log.warn("Insufficient permissions to perform '" + action + "' action on "
                         + currentArtifact.attributes.overview_version + "' version of '"
                         + currentArtifact.attributes.overview_name + "' " + appType + " for '" + user.username
                         + "' user.");
                response.status = 401;
                response.contentType = CONTENT_TYPE_JSON;
                content.status = "Insufficient Permissions";
                content.messages.push("You do not have enough permissions to perform '" + action + "' action on '"
                                      + currentArtifact.attributes.overview_version + "' version of '"
                                      + currentArtifact.attributes.overview_name + "' " + appType + ".");
                response.content = stringify(content);
                return;
            }
        } catch (e) {
            // this exception is thrown by
            // org.wso2.carbon.user.core.AuthorizationManager.isRoleAuthorized(roleName,
            // resourceId, action) throws UserStoreException
            log.error("Cannot retrieve permissions for '" + action + "' action on artifact in '" +
                      currentArtifact.path + "' for user '" + user.username + "'.");
            log.error(e);
            response.status = 500;
            response.contentType = CONTENT_TYPE_JSON;
            content.status = "Error";
            content.messages.push("Cannot retrieve permissions for '" + action + "' action.");
            response.content = stringify(content);
            return;
        }

        /**
         * If everything went correctly in previous executions, previousArtifacts array should
         * contain only 01 item. However due to some failures, previousArtifacts can contain
         * multiple items. That means there are more than 1 published version of this app.
         * In order to handle both situations, previousArtifacts array is processed as a
         * multi-item array in the following code.
         * @type {Object[]}
         */
        var previousArtifacts = [];
        // retrieve previously published web app versions (same provider & name)
        try {
            previousArtifacts = artifactManager.find(function (artifact) {
                var provider = (artifact.attributes.overview_provider ==
                                currentArtifact.attributes.overview_provider);
                var name = (artifact.attributes.overview_name ==
                            currentArtifact.attributes.overview_name);
                return (provider && name && (artifact.lifecycleState == 'Published'));
            }, null);
        } catch (e) {
            log.error("Cannot retrieve previously published " + appType + " "
                      + currentArtifact.attributes.overview_name + " by "
                      + currentArtifact.attributes.overview_provider + ".");
            log.error(e);
            // continue work flow
        }

        /** @type {{isSuccess: boolean, message: string}} */
        var operationResult;

        // promote lifecycle of this app (current artifact)
        operationResult = promoteArtifactLifeCycle(artifactManager, currentArtifact,
                                                   appType, action);
        if (operationResult.isSuccess) {
            content.messages.push(operationResult.message);
        } else {
            // some error occurred in promoteArtifactLifeCycle function,
            // revert previously unpublished artifacts to Publish state
            for (var i = 0; i < previousArtifacts.length; i++) {
                promoteArtifactLifeCycle(artifactManager, previousArtifacts[i], appType, LIFE_CYCLE_ACTION_RE_PUBLISH);
                // ignore errors when reverting changes
            }
            response.status = 500;
            response.contentType = CONTENT_TYPE_JSON;
            content.status = "Error";
            content.messages.push(operationResult.message); // error message from last operation
            response.content = stringify(content);
            return;
        }

        // add comments for life cycle promotion
        try {
            // content type of the PUT request should be 'application/json'
            var comment = (context.content) ? context.content.comment : null;
            if (comment) {
                var lcHistory = artifactManager.getLifecycleHistory(currentArtifact);
                var lcHistoryXML = new XML(lcHistory.content);
                var lcHistoryJSON = utility.xml.convertE4XtoJSON(lcHistoryXML);
                var newChangeOrder = lcHistoryJSON.item[0].order;
                var commentHandler = require('/modules/comment.js');
                commentHandler.addLifecycleComment(artifactManager, currentArtifact.path, comment, newChangeOrder);
            }
        } catch (e) {
            log.error("Cannot add '" + comment + "' comment for '" + action + "' action on "
                      + "artifact in '" + currentArtifact.path + "' for user '" + user.username + "'.");
            log.error(e);
            // continue work flow
        }

        // only when publishing
        if ((action == LIFE_CYCLE_ACTION_PUBLISH) || ((action == LIFE_CYCLE_ACTION_RE_PUBLISH))) {
            //Enforcing restrict visibility logic
            var registry = new carbon.registry.Registry(server, {
                username: server.current(session).username,
                tenantId: server.current(session).tenantId
            });
            var roleRestrictionPath = currentArtifact.path + "role_restrictions";
            try {
                var permissionSet = registry.get(roleRestrictionPath);
                if (Object.keys(permissionSet.content).length > 0) {
                    userManager.denyRole('Internal/everyone', currentArtifact.path,
                                         carbon.registry.actions.GET);
                    userManager.denyRole('system/wso2.anonymous.role', currentArtifact.path,
                                         carbon.registry.actions.GET);
                }
            } catch (e) {
                log.error("No role restrictions found for artifact in '" + currentArtifact.path + "'.");
                log.error(e);
                // continue work flow
            }
        }

        // For all previously published web apps when publishing or re-publishing current web app,
        // move subscriptions of that web app version to this web app version.
        if ((appType == APP_TYPE_WEB_APP) && (previousArtifacts.length > 0)
            && ((action == LIFE_CYCLE_ACTION_PUBLISH) || (action == LIFE_CYCLE_ACTION_RE_PUBLISH))
            && (currentArtifact.attributes.overview_makeAsDefaultVersion.equals("true"))) {


            for (i = 0; i < previousArtifacts.length; i++) {
                //Move subscriptions only from the original older version which this web app was created
                if (previousArtifacts[i].attributes.overview_version
                    == currentArtifact.attributes.overview_oldVersion) {
                    operationResult = moveSubscriptions(previousArtifacts[i], currentArtifact, appType);
                    if (operationResult.isSuccess) {
                        content.messages.push(operationResult.message);
                    } else {
                        // some error occurred in moveSubscriptions function
                        // abort further subscription moving
                        break;
                    }
                }
            }

            if (!operationResult.isSuccess) {
                // something went wrong in the above loop, revert subscription moving
                if (previousArtifacts.length == 1) {
                    // if there are more than 1 previously published app,
                    // then we cannot revert moved subscriptions :(
                    moveSubscriptions(currentArtifact, previousArtifacts[0], appType);
                    // ignore errors when reverting changes
                }
                // revert this app (current artifact) to unpublish state
                promoteArtifactLifeCycle(artifactManager, currentArtifact, appType, LIFE_CYCLE_ACTION_UNPUBLISH);
                // revert previously unpublished artifacts to Publish state
                for (i = 0; i < previousArtifacts.length; i++) {
                    promoteArtifactLifeCycle(artifactManager, previousArtifacts[i], appType,
                                             LIFE_CYCLE_ACTION_RE_PUBLISH);
                    // ignore errors when reverting changes
                }
                response.status = 500;
                response.contentType = CONTENT_TYPE_JSON;
                content.status = "Error";
                content.messages.push(operationResult.message); // error message from last operation
                response.content = stringify(content);
                return;
            }

        }

        // everything went great
        response.status = 200;
        response.contentType = CONTENT_TYPE_JSON;
        content.status = "Success";
        content.artifacts = [currentArtifact].concat(previousArtifacts);
        content.artifacts.forEach(function (artifact) {
            artifact.isDownloadable = hasPermission;
            artifact.attributes.overview_createdtime =
                new Date(parseInt(artifact.attributes.overview_createdtime)).toUTCString();
            artifact.lifecycleState = artifactManager.getLifecycleState(artifact);
            artifact.lifecycleAvailableActions = artifactManager.availableActions(artifact);
        });
        response.content = stringify(content);

    });

    /**
     * Promotes the given <code>artifact</code> to the next status by performing the specified
     * <code>action</code> on it.
     * @param artifactManager {Object} artifact manager
     * @param artifact {Object} artifact to be promoted
     * @param artifactType {string} type of the artifact (e.g. webapp, mobileapp)
     * @param action {string} action to be perform; see '/config/publisher.json'.publisherActions
     * @returns {{isSuccess: boolean, message: string}} status of the operation with a message
     */
    function promoteArtifactLifeCycle(artifactManager, artifact, artifactType, action) {
        var result = {isSuccess: false, message: ""};
        try {
            artifactManager.promoteLifecycleState(action, artifact);
            result.isSuccess = true;
            result.message = getMessageForLifeCyclePromotion(artifact, artifactType, action, true);
        } catch (e) {
            // this exception is thrown by
            // GovernanceArtifactImpl.invokeAction(action) throws GovernanceException
            result.isSuccess = false;
            result.message = getMessageForLifeCyclePromotion(artifact, artifactType, action, false);
            log.error(result.message);
            log.error(e);
        }
        return result;
    }

    /**
     * Returns a human readable message for a life cycle promotion done for a artifact.
     * @param artifact {Object} promoted artifact
     * @param artifactType {string} type of the artifact (e.g. webapp, mobileapp)
     * @param action {string} performed action; see '/config/publisher.json'.publisherActions
     * @param isSuccess {boolean} whether the operation is a success or not
     * @returns {string} a human readable message
     */
    function getMessageForLifeCyclePromotion(artifact, artifactType, action, isSuccess) {
        // Submit for Review, Approve , Reject, Publish, Unpublish, Re-Publish, Deprecate, Retire,
        // Recycle
        if (isSuccess) {
            var msgAction = null;
            if (action == LIFE_CYCLE_ACTION_SUBMIT_FOR_REVIEW) {
                msgAction = "submitted for review"
            } else if ((action == LIFE_CYCLE_ACTION_APPROVE) || (action == LIFE_CYCLE_ACTION_DEPRECATE) ||
                       (action == LIFE_CYCLE_ACTION_RETIRE) || (action == LIFE_CYCLE_ACTION_RECYCLE)) {
                msgAction = action.toLowerCase() + "d";
            } else {
                // Reject, Publish, Unpublish, Re-Publish
                msgAction = action.toLowerCase() + "ed";
            }
            return "Version " + artifact.attributes.overview_version + " of '" +
                   artifact.attributes.overview_name + "' " + artifactType + " " +
                   msgAction + " successfully.";
        } else {
            return "Cannot perform action '" + action + "' on version " +
                   artifact.attributes.overview_version + " of '" +
                   artifact.attributes.overview_name + "' " + artifactType +
                   " which is in '" + artifact.lifecycleState + "' state.";
        }
    }

    /**
     * Moves subscriptions from one asset to another.
     * @param fromAsset {Object} source asset
     * @param toAsset {Object} destination asset
     * @param assetType {string} type of the asset (e.g. webapp, mobileapp)
     * @returns {{isSuccess: boolean, message: string}} status of the moving with a message
     */
    function moveSubscriptions(fromAsset, toAsset, assetType) {
        var result = {isSuccess: false, message: ""};
        try {
            var apiIdentifier = Packages.org.wso2.carbon.appmgt.api.model.APIIdentifier;
            var apiProviderImpl = Packages.org.wso2.carbon.appmgt.impl.APIProviderImpl;
            var provider = new apiProviderImpl(jagg.getUser());

            var fromIdentifier = new apiIdentifier(fromAsset.attributes.overview_provider,
                                                   fromAsset.attributes.overview_name,
                                                   fromAsset.attributes.overview_version);
            var toIdentifier = new apiIdentifier(toAsset.attributes.overview_provider,
                                                 toAsset.attributes.overview_name,
                                                 toAsset.attributes.overview_version);

            var count = provider.moveSubscriptions(fromIdentifier, toIdentifier);
            result.isSuccess = true;
            result.message = count + " subscription(s) moved from version '" +
                             fromAsset.attributes.overview_version + "' to '" +
                             toAsset.attributes.overview_version + "' of '" +
                             fromAsset.attributes.overview_name + "' " + assetType + ".";
        } catch (e) {
            // this exception is thrown by
            // APIProviderImpl.moveSubscriptions(fromIdentifier, toIdentifier) throws
            //														AppManagementException
            result.isSuccess = false;
            result.message = "Cannot move subscriptions from version '" +
                             fromAsset.attributes.overview_version + "' of '" +
                             fromAsset.attributes.overview_name + "' " + assetType + " to version '" +
                             toAsset.attributes.overview_version + "' of '" +
                             toAsset.attributes.overview_name + "' " + assetType + ".";
            log.error(result.message);
            log.error(e);
        }
        return result;
    }

	/*
	 The function returns the lifecycle structure of a given asset
	 */
	function obtainLifeCycle(type) {
		CommonUtil = Packages.org.wso2.carbon.governance.lcm.util.CommonUtil;
		var rootReg = rxtManager.registry.registry;
		var configReg = rootReg.getChrootedRegistry('/_system/config');

		//Obtain a model of the type
		var model = modelManager.getModel(type);

		var lifecycle = model.get('*.lifeCycle').value;

		var data = CommonUtil.getLifecycleConfiguration(lifecycle, configReg);

		//Convert to an xml
		data = '<?xml version="1.0" encoding="ISO-8859-1"?>' + data;
		var xml = new XML(data);

		//Convert to a json
		data = data.replace('<?xml version="1.0" encoding="ISO-8859-1"?>', '');
		var lcJSON = utility.xml.convertE4XtoJSON(xml);

		return lcJSON;
	}

	routeManager.register('GET', 'publisher', '/publisher/api/lifecycle/{type}/{id}', function (context) {
		try {

			appPublishWFExecutor = org.wso2.carbon.appmgt.impl.workflow.WorkflowExecutorFactory.getInstance().getWorkflowExecutor("AM_APPLICATION_PUBLISH");
			var isAsynchronousFlow = appPublishWFExecutor.isAsynchronus();
			var shortName = context.params.type;
			var id = context.params.id;
			var artifactManager = rxtManager.getArtifactManager(shortName);
			var artifact = artifactManager.get(id);
			var state = artifactManager.getLifecycleState(artifact);
			var actions = artifactManager.availableActions(artifact);
			var lcJSON = obtainLifeCycle(shortName);

			var msg = {};
			msg['status'] = 'ok';
			msg['state'] = state;
			msg['actions'] = actions;
			msg['lifecycle'] = lcJSON;
			msg['asynch'] = isAsynchronousFlow;

			log.debug(msg);
            response.contentType = "application/json";
			print(msg);
		} catch (e) {
			log.debug('The asset with id: ' + id + ' could not be found.The following exception was thrown: ' + e);
			response.sendError(404, 'The asset with id: ' + id + ' could not be found.Please refere to the server log.');
		}
	});

	routeManager.register('GET', 'publisher', '/publisher/api/lifecycle/subscribe/{type}/{id}', function (context) {
		try {
			var shortName = context.params.type;
			var id = context.params.id;
			var artifactManager = rxtManager.getArtifactManager(shortName);
			var artifact = artifactManager.get(id);
			var state = artifactManager.getLifecycleState(artifact);
			var webappProvider = artifact.attributes['overview_provider'];
			var webappName = artifact.attributes['overview_name'];
			var webappVersion = artifact.attributes['overview_version'];

			var apiIdentifier = Packages.org.wso2.carbon.appmgt.api.model.APIIdentifier;
			var apiIdentifierObj = new apiIdentifier(webappProvider, webappName, webappVersion);

			var appMDAO = Packages.org.wso2.carbon.appmgt.impl.dao.AppMDAO;
			var appMDAOObj = new appMDAO();
			var count = appMDAOObj.getAPISubscriptionCountByAPI(apiIdentifierObj);
			var subscribed = false;
			if (count > 0) {
				subscribed = true;
			}

			var msg = {};
			msg['subscribed'] = subscribed;
			msg['state'] = state;

			log.debug(msg);
            response.contentType = "application/json";
			print(msg);
		} catch (e) {
			log.debug('The asset with id: ' + id + ' could not be found.The following exception was thrown: ' + e);
			response.sendError(404, 'The asset with id: ' + id + ' could not be found.Please refere to the server log.');
		}
	});

	routeManager.register('GET', 'publisher', '/publisher/api/lifecycle/information/meta/{type}/roles', function (context) {
		var shortName = context.params.type;
		var carbon = require('carbon');
		var realmService = carbon.server.osgiService('org.wso2.carbon.user.core.service.RealmService');
		var realm = realmService.getTenantUserRealm(server.current(session).tenantId);

		var allRoles = realm.getUserStoreManager().getRoleNames();

		var lifecycleJSON = obtainLifeCycle(shortName);
		var relatedRoles = [];

		// TODO: needs to go in a config
		var criticalRoles = ['admin'];

		lifecycleJSON.configuration[0].lifecycle[0].scxml[0].state.forEach(function (state) {
			if (state.id != "Retired") {
				state.datamodel.forEach(function (dataModel) {
					dataModel.data.forEach(function (data) {
						data.execution.forEach(function (execution) {
							execution.parameter.forEach(function (parameter) {
								if (parameter.name.indexOf('STATE_RULE') > -1) {
									var role = parameter.value.split(':')[0];
									if (role.indexOf('{') === -1) {
										relatedRoles.push(parameter.value.split(':')[0]);
									}
								}
							})
						})
					})
				})
			}
		});

		for (var i = 0; i < criticalRoles.length; i++) {
			if (allRoles.indexOf(criticalRoles[i]) > -1) {
				allRoles.splice(i, 1);
			}
		}
		;

		// TODO: needs to go in a config
		if (relatedRoles.indexOf('Internal/everyone') === -1 && relatedRoles.indexOf('system/wso2.anonymous.role') === -1) {
			// if there are no permissions for anoanymous users and registered users

			for (var i = 0; i < allRoles.length; i++) {
				if (relatedRoles.indexOf(allRoles[i]) === -1) {
					// if the role is not included in the lifecycle, remove the role from the list
                    // of possible roles
					allRoles.splice(i, 1);
				}
			}
		}

		var matchedRoles = [];

		var query = request.getQueryString() && request.getQueryString().split('=')[1];

		if (!query) {
			query = '';
		}

		for (var i = 0; i < allRoles.length; i++) {
			if (allRoles[i].indexOf(query) > -1) {
				matchedRoles.push({
					id: allRoles[i],
					name: allRoles[i]
				});
			}
		}
		;

		matchedRoles = parse(stringify(matchedRoles));

		var hiddenRoles = config.hiddenRoles;

		var filteredRoles = [];

		if (matchedRoles.length > 0) {
			for (var i = 0; i < matchedRoles.length; i++) {
				if ((matchedRoles[i].id.indexOf("Internal/private_") == -1) && (hiddenRoles.indexOf(matchedRoles[i].id) == -1)) {
					filteredRoles.push(matchedRoles[i]);
				}
			}
		}


		response.contentType = 'application/json';
		response.status = 200;
		response.content = filteredRoles;
	});

	routeManager.register('GET', 'publisher', '/publisher/api/lifecycle/checklist/{type}/{id}', function (context) {
		//log.debug('short name: '+context.params.type);

		try {
			log.debug('Entered check list/type/id ');
			var shortName = context.params.type;
			var id = context.params.id;
			var artifactManager = rxtManager.getArtifactManager(shortName);
			var artifact = artifactManager.get(id);
			var checkListItems = artifactManager.getCheckListItemNames(artifact);
			var msg = {};
			msg['status'] = 'ok';
			msg['checkListItems'] = checkListItems;
            response.contentType = "application/json";
			print(msg);
		} catch (e) {
			log.debug('The check list names were not retrieved for artifact: ' + id + ' .The following exception was thrown: ' + e);
			response.sendError(404, 'The check list item names could not be retrieved for artifact: ' + id + ' .Please refer to the server log.');
		}
	});

	/*
	 Gets the checked or unchecked state of a check list item
	 */
	routeManager.register('GET', 'publisher', '/publisher/api/lifecycle/checklistitem/{index}/{type}/{id}', function (context) {
		try {
			log.debug('Entered checklistitem/index/type/id ');
			var checkListItemIndex = context.params.index;
			var shortName = context.params.type;
			var id = context.params.id;

			var artifactManager = rxtManager.getArtifactManager(shortName);

			var artifact = artifactManager.get(id);
			var isChecked = artifactManager.isItemChecked(checkListItemIndex, artifact);
			var msg = {};
			msg['status'] = 'ok';
			msg['index'] = checkListItemIndex;
			msg['isChecked'] = isChecked;
            response.contentType = "application/json";
			print(msg);
		} catch (e) {
			log.debug('The check list item index state could not be  retrieved for aritfact: ' + id + ' .The following exception was thrown: ' + e);
			response.sendError(404, 'The check list item state could not be retrieved for artifact: ' + id + ' .Please refer to the server log.');
		}
	});

	routeManager.register('GET', 'publisher', '/publisher/api/lifecycle/information/history/{type}/{id}/{version}', function (context) {
		try {
			var shortName = context.params.type;
			var id = context.params.id;
			var artifactManager = rxtManager.getArtifactManager(shortName);
			var artifact = artifactManager.get(id);
			var historyRes = artifactManager.getLifecycleHistory(artifact);
			var historyComments = require('/modules/comment.js').getLifecycleComments(artifactManager, artifact);
			var json = {};

			if (historyRes != undefined) {
				var xml = new XML(historyRes.content);
				json = utility.xml.convertE4XtoJSON(xml);
			}
            response.contentType = "application/json";
			print(json);
		} catch (e) {
			log.debug('The lifecycle history for artifact: ' + id + ' could not be found.The following exception was thrown: ' + e);
			response.sendError(404, 'The lifecycle history details could not be retrieved for artifact: ' + id + '.Pleas refer to the server log.');
		}
	});

	var securityModule = require('/modules/security/security.manager.js').securityManagementModule();

	var sm = securityModule.cached();

    //This will short circuit the handling of the requests
	var passed = sm.check(session, function () {
		response.sendError(401);
	});

	//Stop servicing the request if the check failed
	if (passed) {
		var store = require('store');
		var user = store.user;
		var utility = require('/modules/utility.js').rxt_utility();
		var server = store.server;

		var publisher = require('/modules/publisher.js').publisher(request, session);
		var rxtManager = publisher.rxtManager;
		var modelManager = publisher.modelManager;

		routeManager.handle(request, response);
	}

}, request, response, session);

%>
